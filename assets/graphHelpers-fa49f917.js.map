{"version":3,"file":"graphHelpers-fa49f917.js","sources":["../../src/helpers/graphHelpers.ts"],"sourcesContent":["import { EdgeData, NodeData } from '../types';\n\n/**\n * Helper function to determine if edge already has a link.\n */\nexport function hasLink(edges: EdgeData[], from: NodeData, to: NodeData) {\n  return edges.some((e) => e.from === from.id && e.to === to.id);\n}\n\n/**\n * Get sources pointing to a node.\n */\nfunction getSourceNodesForTargetId(\n  nodes: NodeData[],\n  edges: EdgeData[],\n  nodeId: string\n) {\n  const sourceNodeIds = edges.reduce((acc, edge) => {\n    if (edge.to === nodeId) {\n      acc.push(edge.from);\n    }\n    return acc;\n  }, []);\n\n  const node = nodes.find((n) => n.id === nodeId);\n\n  if (node?.parent) {\n    sourceNodeIds.push(node.parent);\n  }\n\n  return nodes.filter((n) => sourceNodeIds.includes(n.id));\n}\n\n/**\n * Detect if there is a circular reference from the from to the source node.\n */\nexport function detectCircular(\n  nodes: NodeData[],\n  edges: EdgeData[],\n  fromNode: NodeData,\n  toNode: NodeData\n) {\n  let found = false;\n\n  const traverse = (nodeId: string) => {\n    const sourceNodes = getSourceNodesForTargetId(nodes, edges, nodeId);\n    for (const node of sourceNodes) {\n      if (node.id !== toNode.id) {\n        traverse(node.id);\n      } else {\n        found = true;\n        break;\n      }\n    }\n  };\n\n  traverse(fromNode.id);\n\n  return found;\n}\n\n/**\n * Given a node id, get all the parent nodes recursively.\n */\nexport const getParentsForNodeId = (\n  nodes: NodeData[],\n  edges: EdgeData[],\n  startId: string\n) => {\n  const result = [];\n\n  const traverse = (nodeId: string) => {\n    const sourceNodes = getSourceNodesForTargetId(nodes, edges, nodeId);\n    for (const node of sourceNodes) {\n      const has = result.find((n) => n.id === node.id);\n      if (!has) {\n        result.push(node);\n        traverse(node.id);\n      }\n    }\n  };\n\n  traverse(startId);\n\n  return result;\n};\n\n/**\n * Get edge data given a node.\n */\nexport function getEdgesByNode(edges: EdgeData[], node: NodeData) {\n  const to = [];\n  const from = [];\n\n  for (const edge of edges) {\n    if (edge.to === node.id) {\n      to.push(edge);\n    }\n    if (edge.from === node.id) {\n      from.push(edge);\n    }\n  }\n\n  return {\n    to,\n    from,\n    all: [...to, ...from]\n  };\n}\n"],"names":["hasLink","edges","from","to","getSourceNodesForTargetId","nodes","nodeId","sourceNodeIds","acc","edge","node","n","detectCircular","fromNode","toNode","found","traverse","sourceNodes"],"mappings":"AAKgB,SAAAA,EAAQC,EAAmBC,EAAgBC,EAAc,CAChE,OAAAF,EAAM,KAAM,GAAM,EAAE,OAASC,EAAK,IAAM,EAAE,KAAOC,EAAG,EAAE,CAC/D,CAKA,SAASC,EACPC,EACAJ,EACAK,EACA,CACA,MAAMC,EAAgBN,EAAM,OAAO,CAACO,EAAKC,KACnCA,EAAK,KAAOH,GACVE,EAAA,KAAKC,EAAK,IAAI,EAEbD,GACN,CAAE,CAAA,EAECE,EAAOL,EAAM,KAAMM,GAAMA,EAAE,KAAOL,CAAM,EAE9C,OAAII,GAAA,MAAAA,EAAM,QACMH,EAAA,KAAKG,EAAK,MAAM,EAGzBL,EAAM,OAAQM,GAAMJ,EAAc,SAASI,EAAE,EAAE,CAAC,CACzD,CAKO,SAASC,EACdP,EACAJ,EACAY,EACAC,EACA,CACA,IAAIC,EAAQ,GAEN,MAAAC,EAAYV,GAAmB,CACnC,MAAMW,EAAcb,EAA0BC,EAAOJ,EAAOK,CAAM,EAClE,UAAWI,KAAQO,EACb,GAAAP,EAAK,KAAOI,EAAO,GACrBE,EAASN,EAAK,EAAE,MACX,CACGK,EAAA,GACR,KACF,CACF,EAGF,OAAAC,EAASH,EAAS,EAAE,EAEbE,CACT"}