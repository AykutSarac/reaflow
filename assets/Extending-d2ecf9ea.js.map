{"version":3,"file":"Extending-d2ecf9ea.js","sources":["../../docs/Utils/Extending.mdx"],"sourcesContent":["import { Meta } from '@storybook/addon-docs/blocks';\n\n<Meta title=\"Docs/Utils/Extending\" />\n\n# Extended utils\n\nThe basic utils will not cover all use-cases.\n\nBelow are a few examples of advanced use-cases **with first-class support for connecting nodes through their `ports`**, built on top of the default built-in utils.\n\n> _Courtesy of [Vadorequest/poc-nextjs-reaflow](https://github.com/Vadorequest/poc-nextjs-reaflow/blob/91275644e9c3d0ed8cf7c2c80d49ef526b5e5069/src/utils/nodes.ts)._\n\n```tsx\nimport BaseEdgeData from '../types/BaseEdgeData';\nimport BaseNodeData from '../types/BaseNodeData';\nimport BasePortData from '../types/BasePortData';\nimport { CanvasDataset } from '../types/CanvasDataset';\nimport { createEdge } from './edges';\nimport {\n  getDefaultFromPort,\n  getDefaultToPort,\n} from './ports';\n\n/**\n * Add a node and optional edge, and automatically link their ports.\n *\n * Automatically connects the fromNode (left node) using its EAST port (right side) to the newNode (right node) using it's WEST port (left side).\n *\n * Similar to reaflow.addNodeAndEdge utility.\n */\nexport function addNodeAndEdgeThroughPorts(\n  nodes: BaseNodeData[],\n  edges: BaseEdgeData[],\n  newNode: BaseNodeData,\n  fromNode?: BaseNodeData,\n  toNode?: BaseNodeData,\n  fromPort?: BasePortData,\n  toPort?: BasePortData,\n): CanvasDataset {\n  // The default destination node is the newly created node\n  toNode = toNode || newNode;\n\n  const newEdge: BaseEdgeData = createEdge(\n    fromNode,\n    toNode,\n    getDefaultFromPort(fromNode, fromPort),\n    getDefaultToPort(toNode, toPort),\n  );\n\n  return {\n    nodes: [...nodes, newNode],\n    edges: [\n      ...edges,\n      ...(fromNode ?\n        [\n          newEdge,\n        ]\n        : []),\n    ],\n  };\n}\n\n/**\n * Helper function for upserting a node in a edge (split the edge in 2 and put the node in between), and automatically link their ports.\n *\n * Automatically connects the left edge to the newNode using it's WEST port (left side).\n * Automatically connects the right edge to the newNode using it's EAST port (right side).\n *\n * Similar to reaflow.upsertNode utility.\n */\nexport function upsertNodeThroughPorts(\n  nodes: BaseNodeData[],\n  edges: BaseEdgeData[],\n  edge: BaseEdgeData,\n  newNode: BaseNodeData,\n): CanvasDataset {\n  const oldEdgeIndex = edges.findIndex(e => e.id === edge.id);\n  const edgeBeforeNewNode = {\n    ...edge,\n    id: `${edge.from}-${newNode.id}`,\n    to: newNode.id,\n  };\n  const edgeAfterNewNode = {\n    ...edge,\n    id: `${newNode.id}-${edge.to}`,\n    from: newNode.id,\n  };\n\n  if (edge.fromPort && edge.toPort) {\n    const fromLeftNodeToWestPort: BasePortData | undefined = newNode?.ports?.find((port: BasePortData) => port?.side === 'WEST');\n    const fromRightNodeToEastPort: BasePortData | undefined = newNode?.ports?.find((port: BasePortData) => port?.side === 'EAST');\n\n    edgeBeforeNewNode.fromPort = edge.fromPort;\n    edgeBeforeNewNode.toPort = fromLeftNodeToWestPort?.id || `${newNode.id}-to`;\n\n    edgeAfterNewNode.fromPort = fromRightNodeToEastPort?.id || `${newNode.id}-from`;\n    edgeAfterNewNode.toPort = edge.toPort;\n  }\n\n  edges.splice(oldEdgeIndex, 1, edgeBeforeNewNode, edgeAfterNewNode);\n\n  return {\n    nodes: [...nodes, newNode],\n    edges: [...edges],\n  };\n}\n\n/**\n * Removes a node between two edges and merges the two edges into one, and automatically link their ports.\n *\n * Similar to reaflow.removeAndUpsertNodes utility.\n */\nexport function removeAndUpsertNodesThroughPorts(\n  nodes: BaseNodeData[],\n  edges: BaseEdgeData[],\n  removeNodes: BaseNodeData | BaseNodeData[],\n  onNodeLinkCheck?: (\n    newNodes: BaseNodeData[],\n    newEdges: BaseEdgeData[],\n    from: BaseNodeData,\n    to: BaseNodeData,\n    port?: BasePortData,\n  ) => undefined | boolean,\n): CanvasDataset {\n  if (!Array.isArray(removeNodes)) {\n    removeNodes = [removeNodes];\n  }\n\n  const nodeIds = removeNodes.map((n) => n.id);\n  const newNodes = nodes.filter((n) => !nodeIds.includes(n.id));\n  const newEdges = edges.filter(\n    (e: BaseEdgeData) => !nodeIds.includes(e?.from as string) && !nodeIds.includes(e?.to as string),\n  );\n\n  for (const nodeId of nodeIds) {\n    const sourceEdges = edges.filter((e) => e.to === nodeId);\n    const targetEdges = edges.filter((e) => e.from === nodeId);\n\n    for (const sourceEdge of sourceEdges) {\n      for (const targetEdge of targetEdges) {\n        const sourceNode = nodes.find((n) => n.id === sourceEdge.from);\n        const targetNode = nodes.find((n) => n.id === targetEdge.to);\n\n        if (sourceNode && targetNode) {\n          const canLink = onNodeLinkCheck?.(\n            newNodes,\n            newEdges,\n            sourceNode,\n            targetNode,\n          );\n\n          if (canLink === undefined || canLink) {\n            const fromPort: BasePortData | undefined = sourceNode?.ports?.find((port: BasePortData) => port?.side === 'EAST');\n            const toPort: BasePortData | undefined = targetNode?.ports?.find((port: BasePortData) => port?.side === 'WEST');\n\n            newEdges.push({\n              id: `${sourceNode.id}-${targetNode.id}`,\n              from: sourceNode.id,\n              to: targetNode.id,\n              parent: sourceNode?.parent,\n              fromPort: fromPort?.id,\n              toPort: toPort?.id,\n            });\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    edges: newEdges,\n    nodes: newNodes,\n  };\n}\n\n```\n"],"names":["_createMdxContent","props","_components","_provideComponents","_jsxs","_Fragment","_jsx","Meta","MDXContent","MDXLayout"],"mappings":"0bAIA,SAASA,EAAkBC,EAAO,CAChC,MAAMC,EAAc,OAAO,OAAO,CAChC,GAAI,KACJ,EAAG,IACH,OAAQ,SACR,KAAM,OACN,WAAY,aACZ,GAAI,KACJ,EAAG,IACH,IAAK,KACN,EAAEC,EAAoB,EAAEF,EAAM,UAAU,EACzC,OAAOG,EAAAA,KAAMC,EAAAA,SAAW,CACtB,SAAU,CAACC,EAAI,IAACC,EAAM,CACpB,MAAO,sBACR,CAAA,EAAG;AAAA,EAAMD,MAAKJ,EAAY,GAAI,CAC7B,GAAI,iBACJ,SAAU,gBACX,CAAA,EAAG;AAAA,EAAMI,MAAKJ,EAAY,EAAG,CAC5B,SAAU,+CACX,CAAA,EAAG;AAAA,EAAME,OAAMF,EAAY,EAAG,CAC7B,SAAU,CAAC,kDAAmDE,OAAMF,EAAY,OAAQ,CACtF,SAAU,CAAC,+DAAgEI,MAAKJ,EAAY,KAAM,CAChG,SAAU,OACpB,CAAS,CAAC,CACH,CAAA,EAAG,+CAA+C,CACpD,CAAA,EAAG;AAAA,EAAME,OAAMF,EAAY,WAAY,CACtC,SAAU,CAAC;AAAA,EAAMI,MAAKJ,EAAY,EAAG,CACnC,SAAUE,EAAAA,KAAMF,EAAY,GAAI,CAC9B,SAAU,CAAC,eAAgBI,MAAKJ,EAAY,EAAG,CAC7C,KAAM,qHACN,OAAQ,SACR,IAAK,+BACL,SAAU,gCACX,CAAA,EAAG,GAAG,CACjB,CAAS,CACF,CAAA,EAAG;AAAA,CAAI,CACT,CAAA,EAAG;AAAA,EAAMI,MAAKJ,EAAY,IAAK,CAC9B,SAAUI,EAAAA,IAAKJ,EAAY,KAAM,CAC/B,UAAW,eACX,SAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAClB,CAAO,CACP,CAAK,CAAC,CACN,CAAG,CACH,CACA,SAASM,EAAWP,EAAQ,GAAI,CAC9B,KAAM,CAAC,QAASQ,CAAS,EAAI,OAAO,OAAO,CAAE,EAAEN,EAAoB,EAAEF,EAAM,UAAU,EACrF,OAAOQ,EAAYH,EAAAA,IAAKG,EAAW,OAAO,OAAO,CAAE,EAAER,EAAO,CAC1D,SAAUK,EAAAA,IAAKN,EAAmBC,CAAK,CAC3C,CAAG,CAAC,EAAID,EAAkBC,CAAK,CAC/B"}